<?xml version="1.0" encoding="UTF-8" ?>

<!--
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~       http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="org.flowable.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">

  <!-- HISTORIC PROCESS INSTANCE INSERT -->
  
  <insert id="insertHistoricProcessInstance" parameterType="org.flowable.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
      insert into ${prefix}ACT_HI_PROCINST (
        ID_,
        REV_,
        PROC_INST_ID_,
        BUSINESS_KEY_,
        PROC_DEF_ID_,
        START_TIME_,
        END_TIME_,
        DURATION_,
        START_USER_ID_,
        START_ACT_ID_,
        END_ACT_ID_,
        SUPER_PROCESS_INSTANCE_ID_,
        DELETE_REASON_,
        TENANT_ID_,
        NAME_,
        CALLBACK_ID_,
        CALLBACK_TYPE_,
        REFERENCE_ID_,
        REFERENCE_TYPE_,
        PROPAGATED_STAGE_INST_ID_,
        BUSINESS_STATUS_,
        STATE_,
        END_USER_ID_
      ) values (
        #{id, jdbcType=NVARCHAR},
        1, #{processInstanceId, jdbcType=NVARCHAR},
        #{businessKey, jdbcType=NVARCHAR},
        #{processDefinitionId, jdbcType=NVARCHAR},
        #{startTime, jdbcType=TIMESTAMP},
        #{endTime, jdbcType=TIMESTAMP},
        #{durationInMillis, jdbcType=BIGINT},
        #{startUserId, jdbcType=NVARCHAR},
        #{startActivityId, jdbcType=NVARCHAR},
        #{endActivityId, jdbcType=NVARCHAR},
        #{superProcessInstanceId, jdbcType=NVARCHAR},
        #{deleteReason, jdbcType=NVARCHAR},
        #{tenantId, jdbcType=NVARCHAR},
        #{name, jdbcType=NVARCHAR},
        #{callbackId, jdbcType=NVARCHAR},
        #{callbackType, jdbcType=NVARCHAR},
        #{referenceId, jdbcType=NVARCHAR},
        #{referenceType, jdbcType=NVARCHAR},
        #{propagatedStageInstanceId, jdbcType=NVARCHAR},
        #{businessStatus, jdbcType=NVARCHAR},
        #{state, jdbcType=NVARCHAR},
        #{endUserId, jdbcType=NVARCHAR}
      )
  </insert>
  
  <insert id="bulkInsertHistoricProcessInstance" parameterType="java.util.List">
      insert into ${prefix}ACT_HI_PROCINST (
        ID_,
        REV_,
        PROC_INST_ID_,
        BUSINESS_KEY_,
        PROC_DEF_ID_,
        START_TIME_,
        END_TIME_,
        DURATION_,
        START_USER_ID_,
        START_ACT_ID_,
        END_ACT_ID_,
        SUPER_PROCESS_INSTANCE_ID_,
        DELETE_REASON_,
        TENANT_ID_,
        NAME_,
        CALLBACK_ID_,
        CALLBACK_TYPE_,
        REFERENCE_ID_,
        REFERENCE_TYPE_,
        PROPAGATED_STAGE_INST_ID_,
        BUSINESS_STATUS_,
        STATE_,
        END_USER_ID_
      ) values
        <foreach collection="list" item="historicProcessInstance" index="index" separator=",">
          (
           #{historicProcessInstance.id, jdbcType=NVARCHAR},
           1, #{historicProcessInstance.processInstanceId, jdbcType=NVARCHAR},
           #{historicProcessInstance.businessKey, jdbcType=NVARCHAR},
           #{historicProcessInstance.processDefinitionId, jdbcType=NVARCHAR},
           #{historicProcessInstance.startTime, jdbcType=TIMESTAMP},
           #{historicProcessInstance.endTime, jdbcType=TIMESTAMP},
           #{historicProcessInstance.durationInMillis, jdbcType=BIGINT},
           #{historicProcessInstance.startUserId, jdbcType=NVARCHAR},
           #{historicProcessInstance.startActivityId, jdbcType=NVARCHAR},
           #{historicProcessInstance.endActivityId, jdbcType=NVARCHAR},
           #{historicProcessInstance.superProcessInstanceId, jdbcType=NVARCHAR},
           #{historicProcessInstance.deleteReason, jdbcType=NVARCHAR},
           #{historicProcessInstance.tenantId, jdbcType=NVARCHAR},
           #{historicProcessInstance.name, jdbcType=NVARCHAR},
           #{historicProcessInstance.callbackId, jdbcType=NVARCHAR},
           #{historicProcessInstance.callbackType, jdbcType=NVARCHAR},
           #{historicProcessInstance.referenceId, jdbcType=NVARCHAR},
           #{historicProcessInstance.referenceType, jdbcType=NVARCHAR},
           #{historicProcessInstance.propagatedStageInstanceId, jdbcType=NVARCHAR},
           #{historicProcessInstance.businessStatus, jdbcType=NVARCHAR},
           #{historicProcessInstance.state, jdbcType=NVARCHAR},
           #{historicProcessInstance.endUserId, jdbcType=NVARCHAR}
          )
         </foreach>
  </insert>
  
  <insert id="bulkInsertHistoricProcessInstance" databaseId="oracle" parameterType="java.util.List">
      INSERT ALL 
        <foreach collection="list" item="historicProcessInstance" index="index">
          INTO ${prefix}ACT_HI_PROCINST (
            ID_,
            REV_,
            PROC_INST_ID_,
            BUSINESS_KEY_,
            PROC_DEF_ID_,
            START_TIME_,
            END_TIME_,
            DURATION_,
            START_USER_ID_,
            START_ACT_ID_,
            END_ACT_ID_,
            SUPER_PROCESS_INSTANCE_ID_,
            DELETE_REASON_,
            TENANT_ID_,
            NAME_,
            CALLBACK_ID_,
            CALLBACK_TYPE_,
            REFERENCE_ID_,
            REFERENCE_TYPE_,
            PROPAGATED_STAGE_INST_ID_,
            BUSINESS_STATUS_,
            STATE_,
            END_USER_ID_
          ) VALUES
              (
               #{historicProcessInstance.id, jdbcType=NVARCHAR},
               1, #{historicProcessInstance.processInstanceId, jdbcType=NVARCHAR},
               #{historicProcessInstance.businessKey, jdbcType=NVARCHAR},
               #{historicProcessInstance.processDefinitionId, jdbcType=NVARCHAR},
               #{historicProcessInstance.startTime, jdbcType=TIMESTAMP},
               #{historicProcessInstance.endTime, jdbcType=TIMESTAMP},
               #{historicProcessInstance.durationInMillis, jdbcType=BIGINT},
               #{historicProcessInstance.startUserId, jdbcType=NVARCHAR},
               #{historicProcessInstance.startActivityId, jdbcType=NVARCHAR},
               #{historicProcessInstance.endActivityId, jdbcType=NVARCHAR},
               #{historicProcessInstance.superProcessInstanceId, jdbcType=NVARCHAR},
               #{historicProcessInstance.deleteReason, jdbcType=NVARCHAR},
               #{historicProcessInstance.tenantId, jdbcType=NVARCHAR},
               #{historicProcessInstance.name, jdbcType=NVARCHAR},
               #{historicProcessInstance.callbackId, jdbcType=NVARCHAR},
               #{historicProcessInstance.callbackType, jdbcType=NVARCHAR},
               #{historicProcessInstance.referenceId, jdbcType=NVARCHAR},
               #{historicProcessInstance.referenceType, jdbcType=NVARCHAR},
               #{historicProcessInstance.propagatedStageInstanceId, jdbcType=NVARCHAR},
               #{historicProcessInstance.businessStatus, jdbcType=NVARCHAR},
               #{historicProcessInstance.state, jdbcType=NVARCHAR},
               #{historicProcessInstance.endUserId, jdbcType=NVARCHAR}
              )
       </foreach>
    SELECT * FROM dual
  </insert>

  <!-- HISTORIC PROCESS INSTANCE UPDATE -->
  
  <update id="updateHistoricProcessInstance" parameterType="org.flowable.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    update ${prefix}ACT_HI_PROCINST
      <set>
        REV_ = #{revisionNext, jdbcType=INTEGER},
        <if test="originalPersistentState.processDefinitionId != processDefinitionId">
          PROC_DEF_ID_ = #{processDefinitionId, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.businessKey != businessKey">
          BUSINESS_KEY_ = #{businessKey, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.startTime != startTime">
          START_TIME_ = #{startTime, jdbcType=TIMESTAMP},
        </if>
        <if test="originalPersistentState.endTime != endTime">
          END_TIME_ = #{endTime, jdbcType=TIMESTAMP},
        </if>
        <if test="originalPersistentState.durationInMillis != durationInMillis">
          DURATION_ = #{durationInMillis, jdbcType=BIGINT},
        </if>
        <if test="originalPersistentState.endActivityId != endActivityId">
          END_ACT_ID_ = #{endActivityId, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.deleteReason != deleteReason">
          DELETE_REASON_ = #{deleteReason, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.name != name">
          NAME_ = #{name, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.callbackId != callbackId">
          CALLBACK_ID_ = #{callbackId, jdbcType=NVARCHAR},
        </if> 
        <if test="originalPersistentState.callbackType != callbackType">
          CALLBACK_TYPE_ = #{callbackType, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.referenceId != referenceId">
          REFERENCE_ID_ = #{referenceId, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.referenceType != referenceType">
          REFERENCE_TYPE_ = #{referenceType, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.propagatedStageInstanceId != propagatedStageInstanceId">
          PROPAGATED_STAGE_INST_ID_ = #{propagatedStageInstanceId, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.businessStatus != businessStatus">
          BUSINESS_STATUS_ = #{businessStatus, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.state != state">
          STATE_ = #{state, jdbcType=NVARCHAR},
        </if>
        <if test="originalPersistentState.endUserId != endUserId">
          END_USER_ID_ = #{endUserId, jdbcType=NVARCHAR},
        </if>
      </set>
    where ID_ = #{id, jdbcType=NVARCHAR}
    and REV_ = #{revision, jdbcType=INTEGER}
  </update>

  <!-- HISTORIC PROCESS INSTANCE DELETE -->
  
  <delete id="deleteHistoricProcessInstance">
    delete from ${prefix}ACT_HI_PROCINST where PROC_INST_ID_ = #{processInstanceId, jdbcType=NVARCHAR}
  </delete>
  
  <delete id="bulkDeleteHistoricProcessInstance" parameterType="java.util.Collection">
    delete from ${prefix}ACT_HI_PROCINST where
     <foreach item="historicProcessInstance" collection="list" index="index" separator=" or ">
        ID_ = #{historicProcessInstance.id, jdbcType=NVARCHAR}
    </foreach>
  </delete>
  
  <delete id="bulkDeleteHistoricProcessInstancesByIds" parameterType="java.util.Collection">
    delete from ${prefix}ACT_HI_PROCINST where 
    <foreach item="listItem" index="listIndex" collection="collection">
        <if test="listIndex &gt; 0">
        or
        </if>
        ID_ in
        <foreach item="id" index="index" collection="listItem" open="(" separator="," close=")">
          #{id, jdbcType=NVARCHAR}
        </foreach>
    </foreach>
  </delete>
  
  <!-- HISTORIC PROCESS INSTANCE RESULT MAP -->
  
  <resultMap id="historicProcessInstanceResultMap" type="org.flowable.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    <id property="id" column="ID_" jdbcType="NVARCHAR" />
    <result property="revision" column="REV_" jdbcType="INTEGER"/>
    <result property="processInstanceId" column="PROC_INST_ID_" jdbcType="NVARCHAR" />
    <result property="businessKey" column="BUSINESS_KEY_" jdbcType="NVARCHAR"/>
    <result property="businessStatus" column="BUSINESS_STATUS_" jdbcType="NVARCHAR"/>
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="NVARCHAR" />
    <result property="processDefinitionName" column="PROC_DEF_NAME_" jdbcType="NVARCHAR" /> 
    <result property="processDefinitionKey" column="PROC_DEF_KEY_" jdbcType="NVARCHAR" />
    <result property="processDefinitionVersion" column="PROC_DEF_VERSION_" jdbcType="INTEGER" />
    <result property="processDefinitionCategory" column="PROC_DEF_CATEGORY_" jdbcType="NVARCHAR"/>
    <result property="deploymentId" column="DEPLOYMENT_ID_" jdbcType="NVARCHAR" />
    <result property="startTime" column="START_TIME_" jdbcType="TIMESTAMP" />
    <result property="endTime" column="END_TIME_" jdbcType="TIMESTAMP" />
    <result property="durationInMillis" column="DURATION_" jdbcType="BIGINT" />
    <result property="startUserId" column="START_USER_ID_" jdbcType="NVARCHAR" />
    <result property="startActivityId" column="START_ACT_ID_" jdbcType="NVARCHAR" />
    <result property="endActivityId" column="END_ACT_ID_" jdbcType="NVARCHAR" />
    <result property="superProcessInstanceId" column="SUPER_PROCESS_INSTANCE_ID_" jdbcType="NVARCHAR" />
    <result property="deleteReason" column="DELETE_REASON_" jdbcType="NVARCHAR" />
    <result property="tenantId" column="TENANT_ID_" jdbcType="NVARCHAR" />
    <result property="name" column="NAME_" jdbcType="NVARCHAR" />
    <result property="callbackId" column="CALLBACK_ID_" jdbcType="NVARCHAR" />
    <result property="callbackType" column="CALLBACK_TYPE_" jdbcType="NVARCHAR" />
    <result property="referenceId" column="REFERENCE_ID_" jdbcType="NVARCHAR" />
    <result property="referenceType" column="REFERENCE_TYPE_" jdbcType="NVARCHAR" />
    <result property="propagatedStageInstanceId" column="PROPAGATED_STAGE_INST_ID_" jdbcType="NVARCHAR" />
    <result property="state" column="STATE_" jdbcType="NVARCHAR" />
    <result property="endUserId" column="END_USER_ID_" jdbcType="NVARCHAR" />
  </resultMap>
  
  <resultMap id="historicProcessInstanceIdResultMap" type="org.flowable.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    <id property="id" column="ID_" jdbcType="NVARCHAR" />
  </resultMap>
  
  <resultMap id="historicProcessInstanceAndVariablesResultMap" type="org.flowable.engine.impl.persistence.entity.HistoricProcessInstanceEntityImpl">
    <id property="id" column="ID_" jdbcType="NVARCHAR" />
    <result property="revision" column="REV_" jdbcType="INTEGER"/>
    <result property="processInstanceId" column="PROC_INST_ID_" jdbcType="NVARCHAR" />
    <result property="businessKey" column="BUSINESS_KEY_" jdbcType="NVARCHAR"/>
    <result property="businessStatus" column="BUSINESS_STATUS_" jdbcType="NVARCHAR"/>
    <result property="processDefinitionId" column="PROC_DEF_ID_" jdbcType="NVARCHAR" />
    <result property="processDefinitionName" column="PROC_DEF_NAME_" jdbcType="NVARCHAR" /> 
    <result property="processDefinitionKey" column="PROC_DEF_KEY_" jdbcType="NVARCHAR" />
    <result property="processDefinitionVersion" column="PROC_DEF_VERSION_" jdbcType="INTEGER" />
    <result property="processDefinitionCategory" column="PROC_DEF_CATEGORY_" jdbcType="NVARCHAR"/>
    <result property="deploymentId" column="DEPLOYMENT_ID_" jdbcType="NVARCHAR" />
    <result property="startTime" column="START_TIME_" jdbcType="TIMESTAMP" />
    <result property="endTime" column="END_TIME_" jdbcType="TIMESTAMP" />
    <result property="durationInMillis" column="DURATION_" jdbcType="BIGINT" />
    <result property="startUserId" column="START_USER_ID_" jdbcType="NVARCHAR" />
    <result property="startActivityId" column="START_ACT_ID_" jdbcType="NVARCHAR" />
    <result property="endActivityId" column="END_ACT_ID_" jdbcType="NVARCHAR" />
    <result property="superProcessInstanceId" column="SUPER_PROCESS_INSTANCE_ID_" jdbcType="NVARCHAR" />
    <result property="deleteReason" column="DELETE_REASON_" jdbcType="NVARCHAR" />
    <result property="tenantId" column="TENANT_ID_" jdbcType="NVARCHAR" />
    <result property="name" column="NAME_" jdbcType="NVARCHAR" />
    <result property="callbackId" column="CALLBACK_ID_" jdbcType="NVARCHAR" />
    <result property="callbackType" column="CALLBACK_TYPE_" jdbcType="NVARCHAR" />
    <result property="referenceId" column="REFERENCE_ID_" jdbcType="NVARCHAR" />
    <result property="referenceType" column="REFERENCE_TYPE_" jdbcType="NVARCHAR" />
    <result property="propagatedStageInstanceId" column="PROPAGATED_STAGE_INST_ID_" jdbcType="NVARCHAR" />
    <result property="state" column="STATE_" jdbcType="NVARCHAR" />
    <result property="endUserId" column="END_USER_ID_" jdbcType="NVARCHAR" />
    <collection property="queryVariables" column="EXECUTION_ID_" javaType="ArrayList" ofType="org.flowable.variable.service.impl.persistence.entity.HistoricVariableInstanceEntityImpl">
      <id property="id" column="VAR_ID_" jdbcType="NVARCHAR"/>
      <result property="name" column="VAR_NAME_" javaType="String" jdbcType="NVARCHAR" />
      <result property="variableType" column="VAR_TYPE_" javaType="org.flowable.variable.api.types.VariableType" jdbcType="NVARCHAR" />
      <result property="revision" column="VAR_REV_" jdbcType="INTEGER" />
      <result property="processInstanceId" column="VAR_PROC_INST_ID_" jdbcType="NVARCHAR" />
      <result property="executionId" column="VAR_EXECUTION_ID_" jdbcType="NVARCHAR" />
      <result property="taskId" column="VAR_TASK_ID_" jdbcType="NVARCHAR" />
      <result property="metaInfo" column="VAR_META_INFO_" jdbcType="NVARCHAR" />
      <result property="byteArrayRef" column="VAR_BYTEARRAY_ID_" typeHandler="VariableByteArrayRefTypeHandler"/>
      <result property="doubleValue" column="VAR_DOUBLE_" jdbcType="DOUBLE" />
      <result property="textValue" column="VAR_TEXT_" jdbcType="NVARCHAR" />
      <result property="textValue2" column="VAR_TEXT2_" jdbcType="NVARCHAR" />
      <result property="longValue" column="VAR_LONG_" jdbcType="BIGINT" />
    </collection>
  </resultMap>

  <!-- HISTORIC PROCESS INSTANCE SELECT -->
  
  <select id="selectHistoricProcessInstance" resultMap="historicProcessInstanceResultMap">
      select RES.*,
             DEF.KEY_           as PROC_DEF_KEY_,
             DEF.NAME_          as PROC_DEF_NAME_,
             DEF.VERSION_       as PROC_DEF_VERSION_,
             DEF.CATEGORY_      as PROC_DEF_CATEGORY_,
             DEF.DEPLOYMENT_ID_ as DEPLOYMENT_ID_
      from ${prefix}ACT_HI_PROCINST RES
               left outer join ${prefix}ACT_RE_PROCDEF DEF on RES.PROC_DEF_ID_ = DEF.ID_
      where PROC_INST_ID_ = #{processInstanceId, jdbcType=NVARCHAR}
  </select>

  <select id="selectHistoricProcessInstanceIdsByProcessDefinitionId" parameterType="org.flowable.common.engine.impl.db.ListQueryParameterObject" resultType="string">
    select ID_
    from ${prefix}ACT_HI_PROCINST 
    where PROC_DEF_ID_ = #{parameter, jdbcType=NVARCHAR}
  </select>
  
  <select id="selectHistoricProcessInstanceIdsBySuperProcessInstanceId" parameterType="org.flowable.common.engine.impl.db.ListQueryParameterObject" resultMap="historicProcessInstanceResultMap">
      select RES.*,
             DEF.KEY_           as PROC_DEF_KEY_,
             DEF.NAME_          as PROC_DEF_NAME_,
             DEF.VERSION_       as PROC_DEF_VERSION_,
             DEF.CATEGORY_      as PROC_DEF_CATEGORY_,
             DEF.DEPLOYMENT_ID_ as DEPLOYMENT_ID_
      from ${prefix}ACT_HI_PROCINST RES
               left outer join ${prefix}ACT_RE_PROCDEF DEF on RES.PROC_DEF_ID_ = DEF.ID_
      where SUPER_PROCESS_INSTANCE_ID_ = #{parameter, jdbcType=NVARCHAR}
  </select>
  
  <select id="selectHistoricProcessInstanceIdsBySuperProcessInstanceIds" parameterType="org.flowable.common.engine.impl.db.ListQueryParameterObject" resultType="string">
    select ID_ from ${prefix}ACT_HI_PROCINST where 
    <foreach item="listItem" index="listIndex" collection="parameter">
        <if test="listIndex &gt; 0">
            or
        </if>
        SUPER_PROCESS_INSTANCE_ID_ in
        <foreach item="superProcessInstanceId" index="index" collection="listItem" open="(" separator="," close=")">
            #{superProcessInstanceId, jdbcType=NVARCHAR}
        </foreach>
    </foreach>
  </select>

    <select id="selectHistoricProcessInstancesByQueryCriteria" parameterType="org.flowable.engine.impl.HistoricProcessInstanceQueryImpl"
            resultMap="historicProcessInstanceResultMap">
        <if test="needsPaging">${limitBefore}</if>
        SELECT RES.* <if test="needsPaging">${limitBetween}</if>, DEF.KEY_ as PROC_DEF_KEY_, DEF.NAME_ as PROC_DEF_NAME_, DEF.VERSION_ as PROC_DEF_VERSION_,
        DEF.CATEGORY_ as PROC_DEF_CATEGORY_, DEF.DEPLOYMENT_ID_ as DEPLOYMENT_ID_
        <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
        ${orderBy}
        <if test="needsPaging">${limitAfter}</if>
    </select>

    <select id="selectHistoricProcessInstanceCountByQueryCriteria" parameterType="org.flowable.engine.impl.HistoricProcessInstanceQueryImpl" resultType="long">
        select count(distinct RES.ID_)
        <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
    </select>
    
    <select id="selectHistoricProcessInstanceIdsByQueryCriteria" parameterType="org.flowable.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceIdResultMap">
        <if test="needsPaging">${limitBefore}</if>
        SELECT RES.ID_ <if test="needsPaging">${limitBetween}</if>
        <include refid="selectHistoricProcessInstancesByQueryCriteriaSql"/>
        <if test="needsPaging">${limitAfter}</if>
    </select>

    <sql id="selectHistoricProcessInstancesByQueryCriteriaSql">
        from ${prefix}ACT_HI_PROCINST RES
        <!--
                Doing a join on the definition table is OK, since it is a 1:1 relationship.
                This has to be an outer join because historic data might exists, but definitions might have been deleted
        -->
        left outer join ${prefix}ACT_RE_PROCDEF DEF on RES.PROC_DEF_ID_ = DEF.ID_
    <include refid="commonSelectHistoricProcessInstancesByQueryCriteriaSql"/>
  </sql>
  
  <select id="selectHistoricProcessInstancesWithVariablesByQueryCriteria" parameterType="org.flowable.engine.impl.HistoricProcessInstanceQueryImpl" resultMap="historicProcessInstanceAndVariablesResultMap">
    SELECT RES.*,
      VAR.ID_ as VAR_ID_,
      VAR.NAME_ as VAR_NAME_,
      VAR.VAR_TYPE_ as VAR_TYPE_,
      VAR.REV_ as VAR_REV_,
      VAR.PROC_INST_ID_ as VAR_PROC_INST_ID_,
      VAR.EXECUTION_ID_ as VAR_EXECUTION_ID_,
      VAR.TASK_ID_ as VAR_TASK_ID_,
      VAR.META_INFO_ as VAR_META_INFO_,
      VAR.BYTEARRAY_ID_ as VAR_BYTEARRAY_ID_,
      VAR.DOUBLE_ as VAR_DOUBLE_,
      VAR.TEXT_ as VAR_TEXT_,
      VAR.TEXT2_ as VAR_TEXT2_,
      VAR.LAST_UPDATED_TIME_ as VAR_LAST_UPDATED_TIME_,
      VAR.LONG_ as VAR_LONG_
      FROM (
      <!-- top 100 percent is only needed when doing order by in a subselect -->
      <if test="needsPaging">${limitBefore}</if>
      SELECT <if test="_databaseId == 'mssql'">top 100 percent</if> RES.* <if test="needsPaging">${limitBetween}</if>, DEF.KEY_ as PROC_DEF_KEY_, DEF.NAME_ as
      PROC_DEF_NAME_, DEF.VERSION_ as PROC_DEF_VERSION_, DEF.CATEGORY_ as PROC_DEF_CATEGORY_, DEF.DEPLOYMENT_ID_ as DEPLOYMENT_ID_
      <include refid="selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql"/>
      ${orderBy}
      <if test="needsPaging">${limitAfter}</if>
      ) RES
      left outer join ${prefix}ACT_HI_VARINST VAR ON RES.PROC_INST_ID_ = VAR.EXECUTION_ID_
          <if test="variableNamesToInclude != null and !variableNamesToInclude.empty">
              and VAR.NAME_ in
              <foreach item="variableName" collection="variableNamesToInclude" open="(" separator="," close=")">
                  #{variableName, jdbcType=NVARCHAR}
              </foreach>
          </if>
      <if test="needsProcessDefinitionOuterJoin">
          left outer join ${prefix}ACT_RE_PROCDEF DEF on RES.PROC_DEF_ID_ = DEF.ID_
      </if>
      ${outerJoinOrderBy}
  </select>
  
  <sql id="selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql">
    from ${prefix}ACT_HI_PROCINST RES
    <!--
        Doing a join on the definition table is OK, since it is a 1:1 relationship.
        This has to be an outer join because historic data might exists, but definitions might have been deleted
     -->
    left outer join ${prefix}ACT_RE_PROCDEF DEF on RES.PROC_DEF_ID_ = DEF.ID_
    <include refid="commonSelectHistoricProcessInstancesByQueryCriteriaSql"/>
  </sql>
  
  <delete id="bulkDeleteHistoricProcessInstances">
    delete from ${prefix}ACT_HI_PROCINST
    <where>
      <include refid="commonInstanceQuerySql">
        <property name="queryTablePrefix" value=""/>
      </include>
      <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
        and
        <trim prefix="(" prefixOverrides="OR" suffix=")">
          <include refid="commonInstanceOrQuerySql">
            <property name="queryTablePrefix" value=""/>
          </include>
        </trim>
      </foreach>
    </where>
  </delete>
  
  <sql id="commonSelectHistoricProcessInstancesByQueryCriteriaSql">
    <where>
      <include refid="commonInstanceQuerySql">
        <property name="queryTablePrefix" value="RES."/>
      </include>
      <if test="processDefinitionKey != null">
        and DEF.KEY_ = #{processDefinitionKey, jdbcType=NVARCHAR}
      </if>
      <if test="processDefinitionKeyLike != null">
        and DEF.KEY_ like #{processDefinitionKeyLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="processDefinitionKeyLikeIgnoreCase != null">
        and lower(DEF.KEY_) like lower(#{processDefinitionKeyLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="processDefinitionKeyIn != null &amp;&amp; !processDefinitionKeyIn.empty">
        and DEF.KEY_ IN
        <foreach item="processDefinitionKey" index="index" collection="processDefinitionKeyIn"
                 open="(" separator="," close=")">
          #{processDefinitionKey, jdbcType=NVARCHAR}
        </foreach>
      </if>
      <if test="excludeProcessDefinitionKeys != null and !excludeProcessDefinitionKeys.empty">
        and DEF.KEY_ not in
        <foreach item="processDefinitionKey" index="index" collection="excludeProcessDefinitionKeys" open="(" separator="," close=")">
          #{processDefinitionKey, jdbcType=NVARCHAR}
        </foreach>
      </if>
      <if test="processDefinitionVersion != null">
        and DEF.VERSION_ = #{processDefinitionVersion, jdbcType=INTEGER}
      </if>
      <if test="processDefinitionCategory != null">
        and DEF.CATEGORY_ = #{processDefinitionCategory, jdbcType=NVARCHAR}
      </if>
      <if test="processDefinitionCategoryLike != null">
        and DEF.CATEGORY_ like #{processDefinitionCategoryLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="processDefinitionCategoryLikeIgnoreCase != null">
        and lower(DEF.CATEGORY_) like lower(#{processDefinitionCategoryLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="processDefinitionName != null">
        and DEF.NAME_ = #{processDefinitionName, jdbcType=NVARCHAR}
      </if>
      <if test="processDefinitionNameLike != null">
        and DEF.NAME_ like #{processDefinitionNameLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="processDefinitionNameLikeIgnoreCase != null">
        and lower(DEF.NAME_) like lower(#{processDefinitionNameLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="deploymentId != null">
        and DEF.DEPLOYMENT_ID_ = #{deploymentId, jdbcType=NVARCHAR}
      </if>
      <if test="deploymentIds != null &amp;&amp; !deploymentIds.empty">
        and DEF.DEPLOYMENT_ID_ IN
        <foreach item="deploymentId" index="index" collection="deploymentIds"
                 open="(" separator="," close=")">
          #{deploymentId, jdbcType=NVARCHAR}
        </foreach>
      </if>
      <if test="processKeyNotIn != null">
        <foreach collection="processKeyNotIn" index="index" item="processDefinitionKey">
            and DEF.KEY_ not like #{processDefinitionKey, jdbcType=NVARCHAR}${wildcardEscapeClause}
        </foreach>
      </if>
      <foreach collection="queryVariableValues" index="index" item="queryVariableValue">
        <choose>
            <when test="queryVariableValue.operator.equals('EXISTS')">
              and EXISTS (select ID_ from ${prefix}ACT_HI_VARINST where NAME_ = #{queryVariableValue.name, jdbcType=NVARCHAR} and RES.PROC_INST_ID_ = PROC_INST_ID_)
            </when>
            <when test="queryVariableValue.operator.equals('NOT_EXISTS')">
              and NOT EXISTS (select ID_ from ${prefix}ACT_HI_VARINST where NAME_ = #{queryVariableValue.name, jdbcType=NVARCHAR} and RES.PROC_INST_ID_ = PROC_INST_ID_)
            </when>
            <otherwise>
                and exists (
                    select 1
                    from ${prefix}ACT_HI_VARINST V
                    <where>
                        RES.PROC_INST_ID_ = V.PROC_INST_ID_
                        <if test="!queryVariableValue.local">
                            and V.PROC_INST_ID_ = V.EXECUTION_ID_
                        </if>
                        <if test="queryVariableValue.local">
                            and V.PROC_INST_ID_ &lt;&gt; V.EXECUTION_ID_
                        </if>
                        <if test="queryVariableValue.name != null">
                            <!-- Match-all variable-names when name is null -->
                            and V.NAME_= #{queryVariableValue.name, jdbcType=NVARCHAR}
                        </if>
                        <if test="queryVariableValue.needsTypeCheck()">
                            and V.VAR_TYPE_ = #{queryVariableValue.type, jdbcType=NVARCHAR}
                        </if>
                        <if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                            <choose>
                                <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">
                                    and (lower(V.TEXT_)
                                </when>
                                <otherwise>
                                    and (V.TEXT_
                                </otherwise>
                            </choose>
                            <choose>
                                <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
                                <otherwise><include refid="executionVariableOperator" /></otherwise>
                            </choose>
                            #{queryVariableValue.textValue, jdbcType=NVARCHAR}
                            <choose>
                                <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
                            </choose>
                            <if test="queryVariableValue.operator.equals('NOT_EQUALS') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">
                                or V.TEXT_ is null
                            </if>
                            )
                        </if>
                        <if test="queryVariableValue.textValue2 != null">
                            and V.TEXT2_
                            <choose>
                                <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
                                <otherwise><include refid="executionVariableOperator" /></otherwise>
                            </choose>
                            #{queryVariableValue.textValue2, jdbcType=NVARCHAR}
                            <choose>
                                <when test="queryVariableValue.operator.equals('LIKE')">${wildcardEscapeClause}</when>
                            </choose>
                        </if>
                        <if test="queryVariableValue.longValue != null">
                            and (V.LONG_
                            <include refid="executionVariableOperator" />
                            #{queryVariableValue.longValue, jdbcType=BIGINT}
                            <if test="queryVariableValue.operator.equals('NOT_EQUALS') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">
                                or V.LONG_ is null
                            </if>
                            )
                        </if>
                        <if test="queryVariableValue.doubleValue != null">
                            and (V.DOUBLE_
                            <include refid="executionVariableOperator" />
                            #{queryVariableValue.doubleValue, jdbcType=DOUBLE}
                            <if test="queryVariableValue.operator.equals('NOT_EQUALS') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">
                                or V.DOUBLE_ is null
                            </if>
                            )
                        </if>
                        <!-- Null variable type -->
                        <if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                            <choose>
                                <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
                                    and (V.TEXT_ is not null or V.TEXT2_ is not null or V.LONG_ is not null or V.DOUBLE_ is not null or V.BYTEARRAY_ID_ is not null)
                                </when>
                                <otherwise>
                                    and V.TEXT_ is null and V.TEXT2_ is null and V.LONG_ is null and V.DOUBLE_ is null and V.BYTEARRAY_ID_ is null
                                </otherwise>
                            </choose>
                        </if>
                    </where>
                )
            </otherwise>
        </choose>
      </foreach>
      <foreach item="orQueryObject" index="orIndex" collection="orQueryObjects">
        and
        <trim prefix="(" prefixOverrides="OR" suffix=")">
          <include refid="commonInstanceOrQuerySql">
            <property name="queryTablePrefix" value="RES."/>
          </include>
          <if test="orQueryObject.processDefinitionKey != null">
            or DEF.KEY_ = #{orQueryObject.processDefinitionKey, jdbcType=NVARCHAR}
          </if>
          <if test="orQueryObject.processDefinitionKeyLike != null">
            or DEF.KEY_ like #{orQueryObject.processDefinitionKeyLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.processDefinitionKeyLikeIgnoreCase != null">
            or lower(DEF.KEY_) like lower(#{orQueryObject.processDefinitionKeyLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.processDefinitionKeyIn != null &amp;&amp; !orQueryObject.processDefinitionKeyIn.empty">
            or DEF.KEY_ IN
            <foreach item="processDefinitionKey" index="index" collection="orQueryObject.processDefinitionKeyIn"
                     open="(" separator="," close=")">
              #{processDefinitionKey, jdbcType=NVARCHAR}
            </foreach>
          </if>
          <if test="orQueryObject.excludeProcessDefinitionKeys != null &amp;&amp; !orQueryObject.excludeProcessDefinitionKeys.empty">
            or DEF.KEY_ NOT IN
            <foreach item="processDefinitionKey" index="index" collection="orQueryObject.excludeProcessDefinitionKeys"
                     open="(" separator="," close=")">
              #{processDefinitionKey, jdbcType=NVARCHAR}
            </foreach>
          </if>
          <if test="orQueryObject.processDefinitionVersion != null">
            or DEF.VERSION_ = #{orQueryObject.processDefinitionVersion, jdbcType=INTEGER}
          </if>
          <if test="orQueryObject.processDefinitionCategory != null">
            or DEF.CATEGORY_ = #{orQueryObject.processDefinitionCategory, jdbcType=NVARCHAR}
          </if>
          <if test="orQueryObject.processDefinitionCategoryLike != null">
            or DEF.CATEGORY_ like #{orQueryObject.processDefinitionCategoryLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.processDefinitionCategoryLikeIgnoreCase != null">
            or lower(DEF.CATEGORY_) like lower(#{orQueryObject.processDefinitionCategoryLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.processDefinitionName != null">
            or DEF.NAME_ = #{orQueryObject.processDefinitionName, jdbcType=NVARCHAR}
          </if>
          <if test="orQueryObject.processDefinitionNameLike != null">
            or DEF.NAME_ like #{orQueryObject.processDefinitionNameLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.processDefinitionNameLikeIgnoreCase != null">
            or lower(DEF.NAME_) like lower(#{orQueryObject.processDefinitionNameLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
          </if>
          <if test="orQueryObject.deploymentId != null">
            or DEF.DEPLOYMENT_ID_ = #{orQueryObject.deploymentId, jdbcType=NVARCHAR}
          </if>
          <if test="orQueryObject.deploymentIds != null &amp;&amp; !orQueryObject.deploymentIds.empty">
            or DEF.DEPLOYMENT_ID_ IN
            <foreach item="deploymentId" index="index" collection="orQueryObject.deploymentIds"
                     open="(" separator="," close=")">
              #{deploymentId, jdbcType=NVARCHAR}
            </foreach>
          </if>
          <if test="orQueryObject.processKeyNotIn != null">
            or
            <trim prefix="(" prefixOverrides="AND" suffix=")">
              <foreach collection="orQueryObject.processKeyNotIn" index="index" item="processDefinitionKey">
                and DEF.KEY_ not like #{processDefinitionKey, jdbcType=NVARCHAR}${wildcardEscapeClause}
              </foreach>
            </trim>
          </if>
          <foreach collection="orQueryObject.queryVariableValues" index="index" item="queryVariableValue">
            or
            <trim prefix="(" prefixOverrides="AND" suffix=")">
              <choose>
                <when test="queryVariableValue.operator.equals('EXISTS')">
                    and EXISTS (select ID_ from ${prefix}ACT_HI_VARINST where NAME_ = #{queryVariableValue.name, jdbcType=NVARCHAR} and RES.PROC_INST_ID_ = PROC_INST_ID_)
                </when>
                <when test="queryVariableValue.operator.equals('NOT_EXISTS')">
                    and NOT EXISTS (select ID_ from ${prefix}ACT_HI_VARINST where NAME_ = #{queryVariableValue.name, jdbcType=NVARCHAR} and RES.PROC_INST_ID_ = PROC_INST_ID_)
                </when>
                <otherwise>
                    and exists (
                        select 1
                        from ${prefix}ACT_HI_VARINST V
                        <where>
                            RES.PROC_INST_ID_ = PROC_INST_ID_
                            <if test="!queryVariableValue.local">
                                and V.PROC_INST_ID_ = V.EXECUTION_ID_
                            </if>
                            <if test="queryVariableValue.local">
                                and V.PROC_INST_ID_ &lt;&gt; V.EXECUTION_ID_
                            </if>
                            <if test="queryVariableValue.name != null">
                                <!-- Match-all variable-names when name is null -->
                                and V.NAME_= #{queryVariableValue.name, jdbcType=NVARCHAR}
                            </if>
                            <if test="queryVariableValue.needsTypeCheck()">
                                and V.VAR_TYPE_ = #{queryVariableValue.type, jdbcType=NVARCHAR}
                            </if>
                            <if test="queryVariableValue.textValue != null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                                <choose>
                                    <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">
                                        and (lower(V.TEXT_)
                                    </when>
                                    <otherwise>
                                        and (V.TEXT_
                                    </otherwise>
                                </choose>
                                <choose>
                                    <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">LIKE</when>
                                    <otherwise><include refid="executionVariableOperator" /></otherwise>
                                </choose>
                                #{queryVariableValue.textValue, jdbcType=NVARCHAR}
                                <choose>
                                    <when test="queryVariableValue.operator.equals('LIKE') || queryVariableValue.operator.equals('LIKE_IGNORE_CASE')">${wildcardEscapeClause}</when>
                                </choose>
                                <if test="queryVariableValue.operator.equals('NOT_EQUALS') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">
                                    or V.TEXT_ is null
                                </if>
                                )
                            </if>
                            <if test="queryVariableValue.textValue2 != null">
                                and V.TEXT2_
                                <choose>
                                    <when test="queryVariableValue.operator.equals('LIKE')">LIKE</when>
                                    <otherwise><include refid="executionVariableOperator" /></otherwise>
                                </choose>
                                #{queryVariableValue.textValue2, jdbcType=NVARCHAR}
                                <choose>
                                    <when test="queryVariableValue.operator.equals('LIKE')">${wildcardEscapeClause}</when>
                                </choose>
                            </if>
                            <if test="queryVariableValue.longValue != null">
                                and (V.LONG_
                                <include refid="executionVariableOperator" />
                                #{queryVariableValue.longValue, jdbcType=BIGINT}
                                <if test="queryVariableValue.operator.equals('NOT_EQUALS') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">
                                    or V.LONG_ is null
                                </if>
                                )
                            </if>
                            <if test="queryVariableValue.doubleValue != null">
                                and (V.DOUBLE_
                                <include refid="executionVariableOperator" />
                                #{queryVariableValue.doubleValue, jdbcType=DOUBLE}
                                <if test="queryVariableValue.operator.equals('NOT_EQUALS') || queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">
                                    or V.DOUBLE_ is null
                                </if>
                                )
                            </if>
                            <!-- Null variable type -->
                            <if test="queryVariableValue.textValue == null &amp;&amp; queryVariableValue.textValue2 == null &amp;&amp; queryVariableValue.longValue == null &amp;&amp; queryVariableValue.doubleValue == null">
                                <choose>
                                    <when test="queryVariableValue.operator.equals('NOT_EQUALS')">
                                        and (V.TEXT_ is not null or V.TEXT2_ is not null or V.LONG_ is not null or V.DOUBLE_ is not null or V.BYTEARRAY_ID_ is not null)
                                    </when>
                                    <otherwise>
                                        and V.TEXT_ is null and V.TEXT2_ is null and V.LONG_ is null and V.DOUBLE_ is null and V.BYTEARRAY_ID_ is null
                                    </otherwise>
                                </choose>
                            </if>       
                        </where>
                    )
                </otherwise>
              </choose>
            </trim>
          </foreach>
        </trim>
      </foreach>
      <if test="withJobException">
        and exists (
            select 1
            from ${prefix}ACT_RU_TIMER_JOB JOB
            <where>
                RES.PROC_INST_ID_ = JOB.PROCESS_INSTANCE_ID_
                and (JOB.EXCEPTION_MSG_ is not null or  JOB.EXCEPTION_STACK_ID_ is not null)
            </where>
          )
      </if>
    </where>
  </sql>
  
  <sql id="commonInstanceQuerySql">
    <if test="processInstanceId != null">
        ${queryTablePrefix}PROC_INST_ID_ = #{processInstanceId, jdbcType=NVARCHAR}
      </if>
      <if test="processInstanceIds != null and !processInstanceIds.empty">
        and (
        <foreach item="processInstanceIdListItem" index="groupIndex" collection="safeProcessInstanceIds">
            <if test="groupIndex &gt; 0">
            or
            </if>
            ${queryTablePrefix}PROC_INST_ID_ IN
            <foreach item="processInstanceId" index="index" collection="processInstanceIdListItem" open="(" separator="," close=")">
              #{processInstanceId, jdbcType=NVARCHAR}
            </foreach>
        </foreach>
        )
      </if>
      <if test="processDefinitionId != null">
        and ${queryTablePrefix}PROC_DEF_ID_ = #{processDefinitionId, jdbcType=NVARCHAR}
      </if>
      <if test="businessKey != null">
        and ${queryTablePrefix}BUSINESS_KEY_ = #{businessKey, jdbcType=NVARCHAR}
      </if>
      <if test="businessKeyLike != null">
        and ${queryTablePrefix}BUSINESS_KEY_ like #{businessKeyLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="businessKeyLikeIgnoreCase != null">
        and lower(${queryTablePrefix}BUSINESS_KEY_) like lower(#{businessKeyLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="businessStatus != null">
        and ${queryTablePrefix}BUSINESS_STATUS_ = #{businessStatus, jdbcType=NVARCHAR}
      </if>
      <if test="businessStatusLike != null">
        and ${queryTablePrefix}BUSINESS_STATUS_ like #{businessStatusLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="businessStatusLikeIgnoreCase != null">
        and lower(${queryTablePrefix}BUSINESS_STATUS_) like lower(#{businessStatusLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="startedBefore != null">
        and ${queryTablePrefix}START_TIME_ &lt;= #{startedBefore, jdbcType=TIMESTAMP}
      </if>
      <if test="startedAfter != null">
        and ${queryTablePrefix}START_TIME_ &gt;= #{startedAfter, jdbcType=TIMESTAMP}
      </if>
      <if test="finishedBefore != null">
        and ${queryTablePrefix}END_TIME_ &lt;= #{finishedBefore, jdbcType=TIMESTAMP}
      </if>
      <if test="finishedAfter != null">
        and ${queryTablePrefix}END_TIME_ &gt;= #{finishedAfter, jdbcType=TIMESTAMP}
      </if>
      <if test="unfinished">
        and ${queryTablePrefix}END_TIME_ IS NULL
      </if>
      <if test="finished">
        and ${queryTablePrefix}END_TIME_ is not NULL
      </if>
      <if test="notDeleted">
        and ${queryTablePrefix}DELETE_REASON_ IS NULL
      </if>
      <if test="deleted">
        and ${queryTablePrefix}DELETE_REASON_ IS NOT NULL
      </if>
      <if test="activeActivityId != null">
        and EXISTS(select ID_ from ${prefix}ACT_HI_ACTINST A where A.PROC_INST_ID_ = ${queryTablePrefix}ID_ and A.ACT_ID_ = #{activeActivityId, jdbcType=NVARCHAR} and A.END_TIME_ is null)
      </if>
      <if test="activeActivityIds != null">
        and EXISTS(select ID_ from ${prefix}ACT_HI_ACTINST A where A.PROC_INST_ID_ = ${queryTablePrefix}ID_ and A.ACT_ID_ in 
        <foreach item="activeActivityId" index="index" collection="activeActivityIds" open="(" separator="," close=")">
            #{activeActivityId, jdbcType=NVARCHAR}
        </foreach>
        and A.END_TIME_ is null)
      </if>
      <if test="involvedUser != null">
        and (exists(select LINK.USER_ID_ from ${prefix}ACT_HI_IDENTITYLINK LINK where USER_ID_ = #{involvedUser, jdbcType=NVARCHAR} and LINK.PROC_INST_ID_ = ${queryTablePrefix}ID_))
      </if>
      <if test="involvedUserIdentityLink != null">
          and EXISTS(select ID_ from ${prefix}ACT_HI_IDENTITYLINK I where I.PROC_INST_ID_ = ${queryTablePrefix}ID_ and 
          I.USER_ID_ = #{involvedUserIdentityLink.userId, jdbcType=NVARCHAR} and I.TYPE_ = #{involvedUserIdentityLink.type, jdbcType=NVARCHAR})
      </if>
      <if test="involvedGroups != null">
          and EXISTS(
          select ID_ from ${prefix}ACT_HI_IDENTITYLINK LINK where LINK.PROC_INST_ID_ = ${queryTablePrefix}ID_ and 
            (
            <foreach item="involvedGroupListItem" index="groupIndex" collection="safeInvolvedGroups">
                <if test="groupIndex &gt; 0">
                or
                </if>
                LINK.GROUP_ID_ IN
                <foreach item="group" index="index" collection="involvedGroupListItem"
                      open="(" separator="," close=")">
                  #{group, jdbcType=NVARCHAR}
                </foreach>
            </foreach>
            )
          )
      </if>
      <if test="involvedGroupIdentityLink != null">
          and EXISTS(select ID_ from ${prefix}ACT_HI_IDENTITYLINK I where I.PROC_INST_ID_ = ${queryTablePrefix}ID_ and 
          I.GROUP_ID_ = #{involvedGroupIdentityLink.groupId, jdbcType=NVARCHAR} and I.TYPE_ = #{involvedGroupIdentityLink.type, jdbcType=NVARCHAR})
      </if>
      <if test="startedBy != null">
      	and ${queryTablePrefix}START_USER_ID_ = #{startedBy, jdbcType=NVARCHAR}
      </if>
      <if test="state != null">
          and ${queryTablePrefix}STATE_ = #{state, jdbcType=NVARCHAR}
      </if>
      <if test="finishedBy != null">
          and ${queryTablePrefix}END_USER_ID_ = #{finishedBy, jdbcType=NVARCHAR}
      </if>
      <if test="superProcessInstanceId != null">
        and ${queryTablePrefix}SUPER_PROCESS_INSTANCE_ID_ = #{superProcessInstanceId, jdbcType=NVARCHAR}
      </if>
      <if test="excludeSubprocesses">
        and ${queryTablePrefix}SUPER_PROCESS_INSTANCE_ID_ is null
      </if>
      <if test="callbackId != null">
        and ${queryTablePrefix}CALLBACK_ID_ = #{callbackId, jdbcType=NVARCHAR}
      </if>
      <if test="callbackIds != null">
          and ${queryTablePrefix}CALLBACK_ID_ in
          <foreach item="callbackId" index="index" collection="callbackIds" open="(" separator="," close=")">
              #{callbackId, jdbcType=NVARCHAR}
          </foreach>
      </if>
      <if test="callbackType != null">
        and ${queryTablePrefix}CALLBACK_TYPE_ = #{callbackType, jdbcType=NVARCHAR}
      </if>
      <if test="parentCaseInstanceId != null">
          and EXISTS(select 1 from ${prefix}ACT_CMMN_HI_PLAN_ITEM_INST PLANITEM where
            PLANITEM.CASE_INST_ID_ = #{parentCaseInstanceId, jdbcType=VARCHAR}
            and RES.CALLBACK_ID_ = PLANITEM.ID_
            and RES.CALLBACK_TYPE_ = 'cmmn-1.1-to-bpmn-2.0-child-process'
          )
      </if>
      <if test="withoutCallbackId">
        and ${queryTablePrefix}CALLBACK_ID_ is null
      </if>
      <if test="referenceId != null">
          and ${queryTablePrefix}REFERENCE_ID_ = #{referenceId, jdbcType=NVARCHAR}
      </if>
      <if test="referenceType != null">
          and ${queryTablePrefix}REFERENCE_TYPE_ = #{referenceType, jdbcType=NVARCHAR}
      </if>
      <if test="tenantId != null">
        and ${queryTablePrefix}TENANT_ID_ = #{tenantId, jdbcType=NVARCHAR}
      </if>
      <if test="tenantIdLike != null">
        and ${queryTablePrefix}TENANT_ID_ like #{tenantIdLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="tenantIdLikeIgnoreCase != null">
        and lower(${queryTablePrefix}TENANT_ID_) like lower(#{tenantIdLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="withoutTenantId">
        and (${queryTablePrefix}TENANT_ID_ = '' or ${queryTablePrefix}TENANT_ID_ is null)
      </if>
      <if test="name != null">
        and ${queryTablePrefix}NAME_ = #{name, jdbcType=NVARCHAR}
      </if>
      <if test="nameLike != null">
        and ${queryTablePrefix}NAME_ like #{nameLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="nameLikeIgnoreCase != null">
          and lower(${queryTablePrefix}NAME_) like lower(#{nameLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="parentScopeId != null">
          and EXISTS(select 1 from ${prefix}ACT_HI_ENTITYLINK LINK where
            LINK.SCOPE_ID_ = #{parentScopeId, jdbcType=NVARCHAR}
            and LINK.REF_SCOPE_ID_ = RES.ID_
            and LINK.HIERARCHY_TYPE_ = 'parent'
          )
      </if>
      <if test="rootScopeId != null">
          and exists(select 1 from ${prefix}ACT_HI_ENTITYLINK LINK where
          LINK.REF_SCOPE_ID_ = RES.ID_
          and LINK.ROOT_SCOPE_ID_ = #{rootScopeId, jdbcType=NVARCHAR}
          )
      </if>
  </sql>
  
  <sql id="commonInstanceOrQuerySql">
      <if test="orQueryObject.processInstanceId != null">
        ${queryTablePrefix}PROC_INST_ID_ = #{orQueryObject.processInstanceId, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.processInstanceIds != null and !orQueryObject.processInstanceIds.empty">
        or (
        <foreach item="processInstanceIdListItem" index="groupIndex" collection="orQueryObject.safeProcessInstanceIds">
            <if test="groupIndex &gt; 0">
            or
            </if>
            ${queryTablePrefix}PROC_INST_ID_ IN
            <foreach item="processInstanceId" index="index" collection="processInstanceIdListItem" open="(" separator="," close=")">
              #{processInstanceId, jdbcType=NVARCHAR}
            </foreach>
        </foreach>
        )
      </if>
      <if test="orQueryObject.processDefinitionId != null">
        or ${queryTablePrefix}PROC_DEF_ID_ = #{orQueryObject.processDefinitionId, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.businessKey != null">
        or ${queryTablePrefix}BUSINESS_KEY_ = #{orQueryObject.businessKey, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.businessKeyLike != null">
        or ${queryTablePrefix}BUSINESS_KEY_ like #{orQueryObject.businessKeyLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.businessKeyLikeIgnoreCase != null">
        or lower(${queryTablePrefix}BUSINESS_KEY_) like lower(#{orQueryObject.businessKeyLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.businessStatus != null">
        or ${queryTablePrefix}BUSINESS_STATUS_ = #{orQueryObject.businessStatus, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.businessStatusLike != null">
        or ${queryTablePrefix}BUSINESS_STATUS_ like #{orQueryObject.businessStatusLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.businessStatusLikeIgnoreCase != null">
        or lower(${queryTablePrefix}BUSINESS_STATUS_) like lower(#{orQueryObject.businessStatusLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.startedBefore != null">
        or ${queryTablePrefix}START_TIME_ &lt;= #{orQueryObject.startedBefore, jdbcType=TIMESTAMP}
      </if>
      <if test="orQueryObject.startedAfter != null">
        or ${queryTablePrefix}START_TIME_ &gt;= #{orQueryObject.startedAfter, jdbcType=TIMESTAMP}
      </if>
      <if test="orQueryObject.finishedBefore != null">
        or (${queryTablePrefix}END_TIME_ is not NULL and ${queryTablePrefix}END_TIME_ &lt;= #{orQueryObject.finishedBefore, jdbcType=TIMESTAMP})
      </if>
      <if test="orQueryObject.finishedAfter != null">
        or (${queryTablePrefix}END_TIME_ is not NULL and ${queryTablePrefix}END_TIME_ &gt;= #{orQueryObject.finishedAfter, jdbcType=TIMESTAMP})
      </if>
      <if test="orQueryObject.unfinished">
        or ${queryTablePrefix}END_TIME_ IS NULL
      </if>
      <if test="orQueryObject.finished">
        or ${queryTablePrefix}END_TIME_ is not NULL
      </if>
      <if test="orQueryObject.notDeleted">
        or ${queryTablePrefix}DELETE_REASON_ IS NULL
      </if>
      <if test="orQueryObject.deleted">
        or ${queryTablePrefix}DELETE_REASON_ IS NOT NULL
      </if>
      <if test="activeActivityId != null">
        or EXISTS(select ID_ from ${prefix}ACT_HI_ACTINST A where A.PROC_INST_ID_ = ${queryTablePrefix}ID_ and A.ACT_ID_ = #{activeActivityId, jdbcType=NVARCHAR} and A.END_TIME_ is null)
      </if>
      <if test="activeActivityIds != null">
        or EXISTS(select ID_ from ${prefix}ACT_HI_ACTINST A where A.PROC_INST_ID_ = ${queryTablePrefix}ID_ and A.ACT_ID_ in 
        <foreach item="activeActivityId" index="index" collection="activeActivityIds" open="(" separator="," close=")">
            #{activeActivityId, jdbcType=NVARCHAR}
        </foreach>
        and A.END_TIME_ is null)
      </if>
      <if test="orQueryObject.involvedUser != null">
        or (exists(select LINK.USER_ID_ from ${prefix}ACT_HI_IDENTITYLINK LINK where USER_ID_ = #{orQueryObject.involvedUser, jdbcType=NVARCHAR} and LINK.PROC_INST_ID_ = ${queryTablePrefix}ID_))
      </if>
      <if test="orQueryObject.involvedUserIdentityLink != null">
          or EXISTS(select ID_ from ${prefix}ACT_HI_IDENTITYLINK I where I.PROC_INST_ID_ = ${queryTablePrefix}ID_ and 
          I.USER_ID_ = #{orQueryObject.involvedUserIdentityLink.userId, jdbcType=NVARCHAR} and I.TYPE_ = #{orQueryObject.involvedUserIdentityLink.type, jdbcType=NVARCHAR})
      </if>
      <if test="orQueryObject.involvedGroups != null">
        or EXISTS(
              select ID_ from ${prefix}ACT_HI_IDENTITYLINK LINK where LINK.PROC_INST_ID_ = ${queryTablePrefix}ID_ and 
                (
                <foreach item="involvedGroupListItem" index="groupIndex" collection="orQueryObject.safeInvolvedGroups">
                    <if test="groupIndex &gt; 0">
                    or
                    </if>
                    LINK.GROUP_ID_ IN
                    <foreach item="group" index="index" collection="involvedGroupListItem"
                          open="(" separator="," close=")">
                      #{group, jdbcType=NVARCHAR}
                    </foreach>
                </foreach>
                )
        )
      </if>
      <if test="orQueryObject.involvedGroupIdentityLink != null">
          or EXISTS(select ID_ from ${prefix}ACT_HI_IDENTITYLINK I where I.PROC_INST_ID_ = ${queryTablePrefix}ID_ and 
          I.GROUP_ID_ = #{orQueryObject.involvedGroupIdentityLink.groupId, jdbcType=NVARCHAR} and I.TYPE_ = #{orQueryObject.involvedGroupIdentityLink.type, jdbcType=NVARCHAR})
      </if>
      <if test="orQueryObject.startedBy != null">
        or ${queryTablePrefix}START_USER_ID_ = #{orQueryObject.startedBy, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.state != null">
          or ${queryTablePrefix}STATE_ = #{orQueryObject.state, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.finishedBy != null">
          or ${queryTablePrefix}END_USER_ID_ = #{orQueryObject.finishedBy, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.superProcessInstanceId != null">
        or ${queryTablePrefix}SUPER_PROCESS_INSTANCE_ID_ = #{orQueryObject.superProcessInstanceId, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.excludeSubprocesses">
        or ${queryTablePrefix}SUPER_PROCESS_INSTANCE_ID_ is null
      </if>
      <if test="orQueryObject.callbackId != null">
        or ${queryTablePrefix}CALLBACK_ID_ = #{orQueryObject.callbackId, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.callbackIds != null">
          or ${queryTablePrefix}CALLBACK_ID_ in
          <foreach item="callbackId" index="index" collection="orQueryObject.callbackIds" open="(" separator="," close=")">#{callbackId, jdbcType=NVARCHAR}
          </foreach>
      </if>
      <if test="orQueryObject.callbackType != null">
        or ${queryTablePrefix}CALLBACK_TYPE_ = #{orQueryObject.callbackType, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.parentCaseInstanceId != null">
          or EXISTS(select 1 from ${prefix}ACT_CMMN_HI_PLAN_ITEM_INST PLANITEM where
            PLANITEM.CASE_INST_ID_ = #{orQueryObject.parentCaseInstanceId, jdbcType=VARCHAR}
            and RES.CALLBACK_ID_ = PLANITEM.ID_
            and RES.CALLBACK_TYPE_ = 'cmmn-1.1-to-bpmn-2.0-child-process'
          )
      </if>
      <if test="orQueryObject.withoutCallbackId">
          or ${queryTablePrefix}CALLBACK_ID_ is null
      </if>
      <if test="orQueryObject.referenceId != null">
          or ${queryTablePrefix}REFERENCE_ID_ = #{orQueryObject.referenceId, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.referenceType != null">
          or ${queryTablePrefix}REFERENCE_TYPE_ = #{orQueryObject.referenceType, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.tenantId != null">
        or ${queryTablePrefix}TENANT_ID_ = #{orQueryObject.tenantId, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.tenantIdLike != null">
        or ${queryTablePrefix}TENANT_ID_ like #{orQueryObject.tenantIdLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.tenantIdLikeIgnoreCase != null">
        or lower(${queryTablePrefix}TENANT_ID_) like lower(#{orQueryObject.tenantIdLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.withoutTenantId">
        or (${queryTablePrefix}TENANT_ID_ = '' or ${queryTablePrefix}TENANT_ID_ is null)
      </if>
      <if test="orQueryObject.name != null">
        or ${queryTablePrefix}NAME_ = #{orQueryObject.name, jdbcType=NVARCHAR}
      </if>
      <if test="orQueryObject.nameLike != null">
        or ${queryTablePrefix}NAME_ like #{orQueryObject.nameLike, jdbcType=NVARCHAR}${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.nameLikeIgnoreCase != null">
        or lower(${queryTablePrefix}NAME_) like lower(#{orQueryObject.nameLikeIgnoreCase, jdbcType=NVARCHAR})${wildcardEscapeClause}
      </if>
      <if test="orQueryObject.parentScopeId != null">
          or EXISTS(select 1 from ${prefix}ACT_HI_ENTITYLINK LINK where
          LINK.SCOPE_ID_ = #{orQueryObject.parentScopeId, jdbcType=NVARCHAR}
          and LINK.REF_SCOPE_ID_ = RES.ID_
          and LINK.HIERARCHY_TYPE_ = 'parent'
          )
      </if>
      <if test="orQueryObject.rootScopeId != null">
          or exists(select 1 from ${prefix}ACT_HI_ENTITYLINK LINK where
            LINK.REF_SCOPE_ID_ = RES.ID_
            and LINK.ROOT_SCOPE_ID_ = #{orQueryObject.rootScopeId, jdbcType=NVARCHAR}
          )
      </if>
  </sql>
  
  <sql id="executionVariableOperator">
    <choose>
      <when test="queryVariableValue.operator.equals('EQUALS')">=</when>
      <when test="queryVariableValue.operator.equals('EQUALS_IGNORE_CASE')">=</when>
      <when test="queryVariableValue.operator.equals('NOT_EQUALS')">&lt;&gt;</when>
      <when test="queryVariableValue.operator.equals('NOT_EQUALS_IGNORE_CASE')">&lt;&gt;</when>
      <when test="queryVariableValue.operator.equals('GREATER_THAN')">&gt;</when>
      <when test="queryVariableValue.operator.equals('GREATER_THAN_OR_EQUAL')">&gt;=</when>
      <when test="queryVariableValue.operator.equals('LESS_THAN')">&lt;</when>
      <when test="queryVariableValue.operator.equals('LESS_THAN_OR_EQUAL')">&lt;=</when>
   </choose>
  </sql>
 
   <select id="selectHistoricProcessInstanceByNativeQuery" parameterType="java.util.Map" resultMap="historicProcessInstanceResultMap">
    <include refid="org.flowable.common.engine.db.selectByNativeQuery"/>
  </select>
  
  <select id="selectHistoricProcessInstanceCountByNativeQuery" parameterType="java.util.Map" resultType="long">
    ${sql}
  </select>
</mapper>
