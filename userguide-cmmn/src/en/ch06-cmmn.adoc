== CMMN 1.1

=== What is CMMN?

The Case Management Model and Notation (CMMN) is a standard notation and formal specification by the link:$$http://www.omg.org/spec/CMMN/$$[Object Management Group] for repesenting case models.

Flowable contains: 

* A CMMN 1.1 modeler to create CMMN 1.1 case models
* A Java engine that can import and execute CMMN 1.1 case models
* A demonstration UI that executes the case models, allowing users to see and complete human tasks (and their forms)

=== Basic concepts and terminology

The following figure shows a simple CMMN 1.1 diagram:

image::images/cmmn-basic-concepts.png[align="center"]

A *case model* is always visualized as some sort of _folder_ that contains all the case elements. Every case model contains a *plan model* onto which items will be _planned_. 

The elements of a plan model are called *plan items*. Each _plan item_ has a *plan item definition* that gives its type and possible configuration options at runtime. For example, in the figure above, there are three *human task* plan items and one *milestone*. Other examples of plan items are _process tasks, case tasks and stages_.

After having deployed a case model to the Flowable CMMN engine, it's possible to start *case instances* based on this case model. The plan items defined in the case model similarly have *plan item instance* runtime representations that are exposed by, and can be queried using, the Flowable API.

Plan items can have _sentries_: a plan item is said to have _entry criteria_ when a sentry "guards" its activation. These criteria specify conditions that must be satisfied to _trigger the sentry_. For example, in the figure above, the "Milestone One" plan item is _available_ after a case instance is started, but it is _activated_ (in CMMN 1.1 specification terminology: it moves from the _available_ state to the _active_ state) when both human task A and B are completed. Note that sentries can have complex expression in their _if part_, which are not visualized, allowing for much more complex functionality. Also note that there can be multiple sentries, although only one needs to be satisfied to trigger a state transition.

Plan items and the plan model can also have sentries with _exit criteria_, which specify conditions that trigger an _exit_ from that particular plan item. In the figure above, the whole plan model is exited (as are all the child elements that are active at that moment), when human task C completes.

CMMN 1.1 defines a standard XML format in an XSD that is part of the specification. For information, the example in the figure above is represented in XML as shown below.

Some observations:

* The four plan items above are in the XML and they reference their definition with a _definitionRef_. The actual definitions are at the bottom of the _casePlanModel_ element
* The plan items have criteria (entry or exit) that reference a _sentry_ (not the other way around)
* The XML also contains information on how the diagram is visualized (x and y coordinates, widths and heights, and so on), which are omitted below. These elements are important when exchanging case models with other CMMN 1.1 modeling tools to preserve the correct visual representation

[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/CMMN/20151109/MODEL" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xmlns:flowable="http://flowable.org/cmmn" 
             xmlns:cmmndi="http://www.omg.org/spec/CMMN/20151109/CMMNDI" 
             xmlns:dc="http://www.omg.org/spec/CMMN/20151109/DC" 
             xmlns:di="http://www.omg.org/spec/CMMN/20151109/DI" 
             targetNamespace="http://www.flowable.org/casedef">
  <case id="simpleExample" name="Simple Example">
    <casePlanModel id="casePlanModel" name="My Case">
      <planItem id="planItem1" name="Human task A" 
            definitionRef="sid-88199E7C-7655-439C-810B-8849FC52D3EB"></planItem>
      <planItem id="planItem2" name="Milestone One" 
            definitionRef="sid-8BF8A774-A8A7-4F1A-95CF-1E0D61EE5A47">
        <entryCriterion id="sid-62CC4A6D-B29B-4129-93EA-460253C45CDF" 
            sentryRef="sentry1"></entryCriterion>
      </planItem>
      <planItem id="planItem3" name="Human task B" 
            definitionRef="sid-A1FB8733-0DBC-4B38-9830-CBC4D0C4B802"></planItem>
      <planItem id="planItem4" name="Human task C" 
            definitionRef="sid-D3970AFC-7391-4BA7-95BA-51C64D2F41E9"></planItem>
      <sentry id="sentry1">
        <planItemOnPart id="sentryOnPart1" sourceRef="planItem1">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
        <planItemOnPart id="sentryOnPart2" sourceRef="planItem3">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <sentry id="sentry2">
        <planItemOnPart id="sentryOnPart3" sourceRef="planItem4">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <humanTask id="sid-88199E7C-7655-439C-810B-8849FC52D3EB" 
        name="Human task A"></humanTask>
      <milestone id="sid-8BF8A774-A8A7-4F1A-95CF-1E0D61EE5A47" 
        name="Milestone One"></milestone>
      <humanTask id="sid-A1FB8733-0DBC-4B38-9830-CBC4D0C4B802" 
        name="Human task B"></humanTask>
      <humanTask id="sid-D3970AFC-7391-4BA7-95BA-51C64D2F41E9" 
        name="Human task C"></humanTask>
      <exitCriterion id="sid-422626DB-9B40-49D8-955E-641AB96A5BFA" 
        sentryRef="sentry2"></exitCriterion>
    </casePlanModel>
  </case>
  <cmmndi:CMMNDI>
    <cmmndi:CMMNDiagram id="CMMNDiagram_simpleExample">
        ...
    </cmmndi:CMMNDiagram>
  </cmmndi:CMMNDI>
</definitions>
----

=== Programmatic example

In this section we're going to build a simple case model and execute it programmatically through the Java API's of the Flowable CMMN engine in a simple command line example.

The case model we'll build is a (simplified) _employee onboarding_ case with two stages: a phase before and phase after the potential employee has started. In the first stage, someone from the HR departement will complete the tasks, while in the second stage it is the employee completing them. Also, at any point in time, the potential employee can reject the job and stop the whole case instance.

Note that only stages and human tasks are used. In a real case model, there will most likely other plan item types too, like milestones, nested stages, automated tasks, etc.

image::images/cmmn.programmatic.example.png[align="center"]

The XML for this case models is the following:


[source,xml,linenums]
----
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/CMMN/20151109/MODEL" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xmlns:flowable="http://flowable.org/cmmn" 
             xmlns:cmmndi="http://www.omg.org/spec/CMMN/20151109/CMMNDI" 
             xmlns:dc="http://www.omg.org/spec/CMMN/20151109/DC" 
             xmlns:di="http://www.omg.org/spec/CMMN/20151109/DI" 
             targetNamespace="http://www.flowable.org/casedef">
  <case id="employeeOnboarding" name="Simple Example">
    <casePlanModel id="casePlanModel" name="My Case">
      <planItem id="planItem5" name="Prior to starting" 
            definitionRef="sid-025D29E8-BA9B-403D-A684-8C5B52185642"></planItem>
      <planItem id="planItem8" name="After starting" 
            definitionRef="sid-8459EF32-4F4C-4E9B-A6E9-87FDC2299044">
        <entryCriterion id="sid-50B5F12D-FE75-4D05-9148-86574EE6C073" 
            sentryRef="sentry2"></entryCriterion>
      </planItem>
      <planItem id="planItem9" name="Reject job" 
            definitionRef="sid-134E885A-3D58-417E-81E2-66A3E12334F9"></planItem>
      <sentry id="sentry2">
        <planItemOnPart id="sentryOnPart4" sourceRef="planItem5">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <sentry id="sentry3">
        <planItemOnPart id="sentryOnPart5" sourceRef="planItem9">
          <standardEvent>complete</standardEvent>
        </planItemOnPart>
      </sentry>
      <stage id="sid-025D29E8-BA9B-403D-A684-8C5B52185642" name="Prior to starting">
        <planItem id="planItem1" name="Create email address" 
                definitionRef="sid-EA434DDD-E1BE-4AC1-8520-B19ACE8782D2"></planItem>
        <planItem id="planItem2" name="Allocate office" 
                definitionRef="sid-505BA223-131A-4EF0-ABAD-485AEB0F2C96"></planItem>
        <planItem id="planItem3" name="Send joining letter to candidate" 
                definitionRef="sid-D28DBAD5-0F5F-45F4-8553-3381199AC45F">
          <entryCriterion id="sid-4D88C79D-8E31-4246-9541-A4F6A5720AC8" 
            sentryRef="sentry1"></entryCriterion>
        </planItem>
        <planItem id="planItem4" name="Agree start date" 
                definitionRef="sid-97A72C46-C0AD-477F-86DD-85EF643BB97D"></planItem>
        <sentry id="sentry1">
          <planItemOnPart id="sentryOnPart1" sourceRef="planItem1">
            <standardEvent>complete</standardEvent>
          </planItemOnPart>
          <planItemOnPart id="sentryOnPart2" sourceRef="planItem2">
            <standardEvent>complete</standardEvent>
          </planItemOnPart>
          <planItemOnPart id="sentryOnPart3" sourceRef="planItem4">
            <standardEvent>complete</standardEvent>
          </planItemOnPart>
        </sentry>
        <humanTask id="sid-EA434DDD-E1BE-4AC1-8520-B19ACE8782D2" 
            name="Create email address" 
            flowable:candidateGroups="hr"></humanTask>
        <humanTask id="sid-505BA223-131A-4EF0-ABAD-485AEB0F2C96" 
            name="Allocate office" 
            flowable:candidateGroups="hr"></humanTask>
        <humanTask id="sid-D28DBAD5-0F5F-45F4-8553-3381199AC45F" 
            name="Send joining letter to candidate" 
            flowable:candidateGroups="hr"></humanTask>
        <humanTask id="sid-97A72C46-C0AD-477F-86DD-85EF643BB97D" 
            name="Agree start date" 
            flowable:candidateGroups="hr"></humanTask>
      </stage>
      <stage id="sid-8459EF32-4F4C-4E9B-A6E9-87FDC2299044" 
        name="After starting">
        <planItem id="planItem6" name="New starter training" 
                definitionRef="sid-DF7B9582-11A6-40B4-B7E5-EC7AC6029387"></planItem>
        <planItem id="planItem7" name="Fill in paperwork" 
                definitionRef="sid-7BF2B421-7FA0-479D-A8BD-C22EBD09F599"></planItem>
        <humanTask id="sid-DF7B9582-11A6-40B4-B7E5-EC7AC6029387" 
            name="New starter training" 
            flowable:assignee="${potentialEmployee}"></humanTask>
        <humanTask id="sid-7BF2B421-7FA0-479D-A8BD-C22EBD09F599" 
            name="Fill in paperwork" 
            flowable:assignee="${potentialEmployee}"></humanTask>
      </stage>
      <humanTask id="sid-134E885A-3D58-417E-81E2-66A3E12334F9" name="Reject job" 
        flowable:assignee="${potentialEmployee}"></humanTask>
      <exitCriterion id="sid-18277F30-E146-4B3E-B3C9-3F1E187EC7A8" 
        sentryRef="sentry3"></exitCriterion>
    </casePlanModel>
  </case>
</definitions>
----

First of all, create a new project and add the _flowable-cmmn-engine_ dependency (here shown for Maven). The H2 dependency is also added, as H2 will be used as embedded database later on.

[source,xml,linenums]
----
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-cmmn-engine</artifactId>
    <version>${flowable.version}</version>
</dependency>
<dependency>
    <groupId>com.h2database</groupId>
    <artifactId>h2</artifactId>
    <version>${h2.version}</version>
</dependency>
----

The Flowable CMMN API is designed to be consistent with the other Flowable API's and concepts. As such, people that know the BPMN or DMN API's will have no problem finding their way around. As with the other engines, the first line of code is creating a CmmnEngine. Here, the default in-memory configuration is used, which uses H2 as database:

[source,java,linenums]
----
public class Main {
  public static void main(String[] args) {
    CmmnEngine cmmnEngine 
        = new StandaloneInMemCmmnEngineConfiguration().buildCmmnEngine();
  }
}
----

Note that the _CmmnEngineConfiguration_ exposes many configuration options for tweaking various settings of the CMMN engine.

Put the XML from above in a file, for example _my-case.cmmn_ (or .cmmn.xml). For Maven, it should be placed in the _src/main/resources_ folder.

To make the engine aware of the case model, it needs to be _deployed_ first. This is done through the _CmmnRepositoryService_:

[source,java,linenums]
----
CmmnRepositoryService cmmnRepositoryService = cmmnEngine.getCmmnRepositoryService();
CmmnDeployment cmmnDeployment = cmmnRepositoryService.createDeployment()
    .addClasspathResource("my-case.cmmn")
    .deploy();
----

Deploying the XML will return a *CmmnDeployment*. A deployment can contain many case models and artifacts. The specific case model definition of above is stored as a *CaseDefinition*. This can be verified by doing a _CaseDefinitionQuery_:

[source,java,linenums]
----
List<CaseDefinition> caseDefinitions = cmmnRepositoryService.createCaseDefinitionQuery().list();
System.out.println("Found " + caseDefinitions.size() + " case definitions");
----

Having a *CaseDefinition* in the engine, it's now possible to start a *CaseInstance* for this case model definition. Either the result from the query is used and passed into the following snippet of code, or the _key_ of the case definition is used directly (as done below).

Note that we're also passing data, an identifier to the _potentialEmployee_ as a variable when starting the *CaseInstance*. This variable will later be used in the human tasks to assign the task to the correct person (see the _assignee="${potentialEmployee}"_ attribute on _human tasks_).

[source,java,linenums]
----
CmmnRuntimeService cmmnRuntimeService = cmmnEngine.getCmmnRuntimeService();
CaseInstance caseInstance = cmmnRuntimeService.createCaseInstanceBuilder()
    .caseDefinitionKey("employeeOnboarding")
    .variable("potentialEmployee", "johnDoe")
    .start();
----

After the *CaseInstance* is started, the engine will determine which of the plan items of the model should be activated:

* The first stage has no entry criteria, so it's activated
* The child human tasks of the first stage have no entry criteria, so three of them are expected to be active

The plan items are represented at runtime by *PlanItemInstances* and can be queried through the _CmmnRuntimeService_:

[source,java,linenums]
----
List<PlanItemInstance> planItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .orderByName().asc()
    .list();

for (PlanItemInstance planItemInstance : planItemInstances) {
    System.out.println(planItemInstance.getName());
}
----

which prints out

----
After starting
Agree start date
Allocate office
Create email address
Prior to starting
Reject job
Send joining letter to candidate
----

Some things might be unexpected here:

* The stages are _also_ plan items and thus have a representation as *PlanItemInstance*. Note that that child plan item instances will have the stage as parent when calling _.getStageInstanceId()_.
* The _Send joining letter to candidate_ is returned in the result. The reason for that is that, in accordance with the CMMN 1.1 specification, this plan item instance is in the _available_ state, but not yet in the _active_ state.

Indeed, when the code above is changed to

[source,java,linenums]
----
for (PlanItemInstance planItemInstance : planItemInstances) {
    System.out.println(planItemInstance.getName() 
        + ", state=" + planItemInstance.getState() 
        + ", parent stage=" + planItemInstance.getStageInstanceId());
}
----

The output now becomes:

----
After starting, state=available, parent stage=null
Agree start date, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Allocate office, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Create email address, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Prior to starting, state=active, parent stage=null
Reject job, state=active, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
Send joining letter to candidate, state=available, parent stage=fe37ac97-b016-11e7-b3ad-acde48001122
----

To only show the active plan item instances, the query can be adapted by adding _planItemInstanceStateActive()_:

[source,java,linenums]
----
 List<PlanItemInstance> planItemInstances = cmmnRuntimeService.createPlanItemInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .planItemInstanceStateActive()
    .orderByName().asc()
    .list();
----

The output is now

----
Agree start date
Allocate office
Create email address
Prior to starting
Reject job
----

Of course, the *PlanItemInstance* is the low level representation, but each plan item also has a _plan item definition_ that defines what type it is. In this case, we only have _human tasks_. It is possible to interact with the _CaseInstance_ via its _plan item instances_, for example by triggering them programmatically (e.g. _CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)_). However, most likely the interaction will happen through the results of the actual plan item definition, here the human tasks.

Querying for tasks is done in the exact same way as for the BPMN engine (in fact, the task service is a shared component and tasks created in BPMN or CMMN can be queried through both engines):

[source,java,linenums]
----
CmmnTaskService cmmnTaskService = cmmnEngine.getCmmnTaskService();
List<Task> hrTasks = cmmnTaskService.createTaskQuery()
    .taskCandidateGroup("hr")
    .caseInstanceId(caseInstance.getId())
    .orderByTaskName().asc()
    .list();
for (Task task : hrTasks) {
    System.out.println("Task for HR : " + task.getName());
}
        
List<Task> employeeTasks = cmmnTaskService.createTaskQuery()
    .taskAssignee("johndoe")
    .orderByTaskName().asc()
    .list();
for (Task task : employeeTasks) {
    System.out.println("Task for employee: " + task);
}
----

Which outputs:

----
Task for HR : Agree start date
Task for HR : Allocate office
Task for HR : Create email address

Task for employee: Reject job
----

When the three tasks of HR are completed, the 'Send joining letter to candidate' taks should be available:

[source,java,linenums]
----
for (Task task : hrTasks) {
    cmmnTaskService.complete(task.getId());
}

hrTasks = cmmnTaskService.createTaskQuery()
    .taskCandidateGroup("hr")
    .caseInstanceId(caseInstance.getId())
    .orderByTaskName().asc()
    .list();

for (Task task : hrTasks) {
    System.out.println("Task for HR : " + task.getName());
}
----

And indeed, the expected task is now created:

----
Task for HR : Send joining letter to candidate
----

Completing this task will now move the case instance into the second stage, as the sentry for the first stage is satisfied. The 'Reject job' tasks is automatically completed by the system and the two tasks for the employee are now created:

[source,java,linenums]
----
Task for employee: Fill in paperwork
Task for employee: New starter training
Task for employee: Reject job
----

Completing all the tasks will now end the case instance:

----
List<Task> tasks = cmmnTaskService.createTaskQuery().caseInstanceId(caseInstance.getId()).listPage(0, 1);
while (!tasks.isEmpty()) {
    cmmnTaskService.complete(tasks.get(0).getId());
    tasks = cmmnTaskService.createTaskQuery()
        .caseInstanceId(caseInstance.getId())
        .listPage(0, 1);
}
----

While executing case instances, the engine also stores historic information, that can be queried via a query API:

[source,java,linenums]
----
CmmnHistoryService cmmnHistoryService = cmmnEngine.getCmmnHistoryService();
HistoricCaseInstance historicCaseInstance = cmmnHistoryService.createHistoricCaseInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .singleResult();

System.out.println("Case instance execution took " 
    + (historicCaseInstance.getEndTime().getTime() - historicCaseInstance.getStartTime().getTime()) + " ms");
        
List<HistoricTaskInstance> historicTaskInstances = cmmnHistoryService.createHistoricTaskInstanceQuery()
    .caseInstanceId(caseInstance.getId())
    .orderByTaskCreateTime().asc()
    .list();

for (HistoricTaskInstance historicTaskInstance : historicTaskInstances) {
    System.out.println("Task completed: " + historicTaskInstance.getName());
}
----

Which outputs:

----
Case instance execution took 149 ms
Task completed: Reject job
Task completed: Agree start date
Task completed: Allocate office
Task completed: Create email address
Task completed: Send joining letter to candidate
Task completed: New starter training
Task completed: Fill in paperwork
----

Of course, this is but a small part of the available API's and constructs available in the Flowable CMMN Engine. Please check the other sections for more detailed information

=== CMMN 1.1 Constructs

This chapter covers the CMMN 1.1 constructs supported by Flowable, as well as extensions to the CMMN 1.1 standard.

==== Stage

A stage is used to group plan items together. It is typicaly used to define "phases" in a case instance.

A stage is a plan item itself, and thus can have entry and exit criteria. Plan items contained within a stage are only available when the parent stage moves to the _active_ state. Stages can be nested in other stages. 

A stage is visualized as a rectangle with angled corners:

image::images/cmmn.stage.png[align="center"]

==== Task

A "manual" task, meaning the task will happen external to the engine.

Properties:

* *name*: expression that will be resolved at runtime as the name of the human task 
* *blocking*: a boolean value determining whether the task blocks
* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks

If a task is non-blocking, the engine will simply complete it automatically when executing it. If a task is blocking, a _PlanItemInstance_ for this task will remain in the _active_ state until it is programmatically triggered by the _CmmnRuntimeService.triggerPlanItemInstance(String planItemInstanceId)_ method.

A task is visualized as a rounded rectangle:

image::images/cmmn.task.png[align="center"]

==== Human task

A human task is used to model work that needs to be done by a human, typically through a form. When the engine arrives at such a human task, a new entry is created in the task list of any users or groups assigned to that task.

A human task is a plan item, which means that beyond a human task entry aso a _PlanItemInstance_ is created and it can be queried via the _PlanItemInstanceQuery_.

Human tasks can be queried throught the _org.flowable.task.api.TaskQuery_ API. Historic task data can be queries through the _org.flowable.task.api.history.HistoricTaskInstanceQuery_.

Properties:

* *name*: expression that will be resolved at runtime as the name of the human task.
* *blocking*: a boolean value determining whether the task blocks.
* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks.
* *assignee* : an expression (can be a static text value) that is used to determine to who the human task is assigned.
* *owner* : an expression (can be a static text value) that is used to determine to who is the owner of the human task.
* *candidateUsers* : an expression (can be a static text value) that resolves to a comma-seperated list of Strings that is used to determine which users are candidate for this human task.
* *candidateGroups* : an expression (can be a static text value) that resolves to a comma-seperated list of Strings that is used to determine to which groups the task is assigned.
* *form key*: an expression that determines a key when using forms. Can be retrieved via the API afterwards.
* *Due date* an expression that resolves to java.util.Date or a ISO-8601 date string.
* *Priority*: an expression that resolves to an integer. Can be used in the TaskQuery API to filter tasks.

A human task is visualized as a rounded rectangle with a user icon in the top left corner:

image::images/cmmn.humantask.png[align="center"]

==== Java Service task

A service task is used to execute custom logic. 

Custom logic is placed in a class that implements the _org.flowable.cmmn.api.delegate.PlanItemJavaDelegate_ interface.

[source,java,linenums]
----
public class MyJavaDelegate implements PlanItemJavaDelegate {
    
    public void execute(DelegatePlanItemInstance planItemInstance) {
        String value = (String) planItemInstance.getVariable("someVariable");
        ...
    }

}
----

For lower-level implementations that cannot be covered by using the _PlanItemJavaDelegate_ approach, the _CmmnActivityBehavior_ can be used (similar to _JavaDelegate_ vs _ActivityBehavior_ in the BPMN engine). 


Properties:

* *name*: name of the service task.
* *class*: the Java class implementing the custom logic.
* *class fields*: allows to add parameters when calling the custom logic.
* *Delegate expression*: an expression that resolves to a class implementing the _PlanItemJavaDelegate_ interface.

A service task is visualized as a rounded rectangle with a cog icon in the top left corner:

image::images/cmmn.servicetask.png[align="center"]

==== Milestone

A milestone is used to mark arriving at a certain point in the case instance. At runtime, they are represented as *MilestoneInstances* and they can be queried through the *MilestoneInstanceQuery* via the _CmmnRuntimeService_. There is also a historical counterpart via the _CmmnHistoryService_.

A human task is a plan item, which means that beyond a milestone entry aso a _PlanItemInstance_ is created and it can be queried via the _PlanItemInstanceQuery_.


Properties:

* *name*: an expression or static text that determines the name of the mile stone.

A milestone is visualized as a rounded rectangle with, slightly more rounded than a task:

image::images/cmmn.milestone.png[align="center"]

==== Case task

A case task is used to start a child case within the context of another case. The _CaseInstanceQuery_ has _parent_ options to find these cases.

When the case task is blocking, the _PlanItemInstance_ will be _active_ until the child case has completely finished. If the case task is non-blocking, the child case is started and the plan item instance automatically completes. When the child case instance is ended, there is no impact on the parent case.

Properties:

* *name*: an expression or static text that determines the name
* *blocking*: a boolean value determining whether the task blocks
* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks
* *Case reference*: the key of the case definition that is used to start the child case instance. Can be an expression.

A case task is visualized as a rounded rectangle with a case icon in the top left corner:

image::images/cmmn.casetask.png[align="center"]

==== Process task

A process task is used to start a process instance within the context of a case.

When the process task is blocking, the _PlanItemInstance_ will be _active_ until the process instance has completely finished. If the process task is non-blocking, the process instance is started and the plan item instance automatically completes. When the process instance is ended, there is no impact on the parent case.

Properties:

* *name*: an expression or static text that determines the name
* *blocking*: a boolean value determining whether the task blocks
* *blockingExpression*: an expression that evaluates to a boolean indicating whether the tasks blocks
* *Process reference*: the key of the process definition that is used to start the process instance. Can be an expression.

A process task is visualized as a rounded rectangle with an arrow icon in the top left corner:

image::images/cmmn.processtask.png[align="center"]

==== Entry criterion

Entry criteria form a sentry for a given plan item instance. They consist of two parts:

* One or more parts depending on other plan items: these define dependencies on state transitions of other plan items. For example, one human task can depend on the state transition 'complete' of three other human tasks to become active itself.
* One optional _if part_ or _condition_: this is an expression that allows to define a complex condition.

A sentry is satisfied when all of its criteria are resolved to true. When a certain criteria evaluates to true, this is stored and remembered for future evaluations. Note that entry criteria evaluations of all plan item instances in the _available_ state are executed whenever something changes in the case instance.

Multiple sentries are possible on a plan item. However, when one is satisfied, the plan item moves from state _available_ to _active_.

An entry criteria is visualized as a diamond shape (white color inside) on the border of a plan item:

image::images/cmmn.entrycriteria.png[align="center"]

==== Exit criterion

Exit criteria form a sentry for a given plan item instance. They consist of two parts:

* One or more parts depending on other plan items: these define dependencies on state transitions of other plan items. For example, one human task can depend on reaching a certain milestone to be automatically terminated.
* One optional _if part_ or _condition_: this is an expression that allows to define a complex condition.

A sentry is satisfied when all of its criteria are resolved to true. When a certain criteria evaluates to true, this is stored and remembered for future evaluations. Note that exit criteria evaluations of all plan item instances in the _active_ state are executed whenever something changes in the case instance.

Multiple sentries are possible on a plan item. However, when one is satisfied, the plan item moves from state _active_ to _exit_.

An exit criteria is visualized as a diamond shape (white color inside) on the border of a plan item:

image::images/cmmn.exitcriteria.png[align="center"]
